//Деструктизация




const person = {
    name: 'Vladilen',
    age: 26,
    isProgrammer: true,
    languages: ['ru', 'en', 'de'],
    // 'complex key': 'Complex Value',
    // ['key_' + (1 + 3)]: 'Computed Key', // key_4
    greet() {
      console.log('greet from person')
    },
    info() {
      // console.log('this:', this)
      console.info('Информация про человека по имени:', this.name)
    }
  }









const name = person.name
 const age = person.age
 const languages = person.languages

// Что бы так не писать мы можем просто Деструктурировать как на примере ниже:

 const {name, age: personAge = 10, languages} = person
 console.log(person)




 //Корирование

 /*Каррирование или карринг (currying) в функциональном программирование — это преобразование функции с множеством аргументов в набор вложенных функций с одним аргументом. При вызове каррированной функции с передачей ей одного аргумента, она возвращает новую функцию, которая ожидает поступления следующего аргумента. Новые функции, ожидающие следующего аргумента, возвращаются при каждом вызове каррированной функции — до тех пор, пока функция не получит все необходимые ей аргументы. Ранее полученные аргументы, благодаря механизму замыканий, ждут того момента, когда функция получит всё, что ей нужно для выполнения вычислений. После получения последнего аргумента функция выполняет вычисления и возвращает результат.

Говоря о каррировании, можно сказать, что это процесс превращения функции с несколькими аргументами в функцию с меньшей арностью.

Арность — это количество аргументов функции. Например — вот объявление пары функций:*/



function fn(a, b) {
    //...

}
function _fn(a, b, c) {
    //...

}





//Рассмотрим пример. У нас имеется следующая функция:

function multiply(a, b, c) {
    return a * b * c;
}

//Она принимает три аргумента и возвращает их произведение:

multiply(1,2,3); // 6

//Теперь подумаем о том, как преобразовать её к набору функций, каждая из которых принимает один аргумент. Создадим каррированный вариант этой 
//функции и посмотрим на то, как получить тот же результат в ходе вызова нескольких функций:

function multiply(a) {
    return (b) => {
        return (c) => {
            return a * b * c
        }
    }
}
log(multiply(1)(2)(3)) // 6

//Как видите, здесь мы преобразовали вызов единственной функции с тремя аргументами — multiply(1,2,3) к 
//вызову трёх функций — multiply(1)(2)(3).