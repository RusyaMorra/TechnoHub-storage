//Алгоритмы и структуры данных

/*N-натуральные числа
Z-целые числа
Q-рациональные числа
R-действительные числа*/



/*Факториалы натуральных чисел
10285
Факториал натурального числа n (обозначение – “n!“) равен произведению всех натуральных чисел от 1 до n включительно.

n! = 1 * 2 * 3 * 4 … * n

Ниже представлены таблицы с факториалами чисел от 1 до 20 (точные значения) и от 21 до 100 (приближенные значения).


Факториал числа n
(n!)	Значение
1!	1
2!	2
3!	6
4!	24
5!	120
6!	720
7!	5040
8!	40320
9!	362880
10!	3628800
11!	39916800
12!	479001600
13!	6227020800
14!	87178291200
15!	1307674368000
16!	20922789888000
17!	355687428096000
18!	6402373705728000
19!	121645100408832000
20!	2432902008176640000







//логорифмы

Логарифмы всегда считались сложной темой в школьном курсе математики. Существует много разных определений логарифма,
но большинство учебников почему-то используют самые сложные и неудачные из них.Мы же определим логарифм просто и наглядно. Для этого составим таблицу:
21	22	23	24	25	26
2	4	8	16	32	64
Итак, перед нами степени двойки. Если взять число из нижней строчки, то можно легко найти степень, в которую придется возвести двойку, 
чтобы получилось это число. Например, чтобы получить 16, надо два возвести в четвертую степень. А чтобы получить 64, надо два возвести в шестую степень. 
Это видно из таблицы.А теперь — собственно, определение логарифма:Логарифм по основанию a от аргумента x — это степень, в которую надо возвести число a, 
чтобы получить число x.Обозначение: loga x = b, где a — основание, x — аргумент, b — собственно, чему равен логарифм.Например,
 23 = 8 ⇒ log2 8 = 3 (логарифм по основанию 2 от числа 8 равен трем, поскольку 23 = 8). С тем же успехом log2 64 = 6, поскольку 26 = 64.
 Операцию нахождения логарифма числа по заданному основанию называют логарифмированием. Итак, дополним нашу таблицу новой строкой:

 
 2\1	        2\2	           2\3	         2\4	     2\5	      2\6
2            	4	            8	          16	      32	       64
log2 2 = 1	log2 4 = 2	  log2 8 = 3	log2 16 = 4	  log2 32 = 5  	log2 64 = 6















//числа фибоначи
Числа Фибоначчи — это ряд, состоящий из целых чисел. Их особенность заключается в том, что каждый элемент представляет собой сумму двух предыдущих чисел.

Последовательность Фибоначчи начинается с 0 и 1. Продолжить ряд легко: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144 и так до бесконечности.









кеширование - процесс сохранения неких оперативных данных в "быстрой" памяти для быстрого их считывание - например браузер кеширует картинки сайта и не ташит 
их с хостинга каждый раз.. .




хеширование - процесс одностороннего шифрование неких данных - чаще паролей, для невозможности их прочитать












*/






_______________________________________________________________________________________________________________________________________________________________________________


//Алгоритм линейного поиска

const array = [1,4,5,8,5,1,2,7,5,2,11]
let count = 0
function linearSearch(array, item) {
    for (let i = 0; i < array.length; i++) {
        count += 1
        if (array[i] === item) {
            return i;
        }
    }
    return null
}

console.log(linearSearch(array, 1))
console.log('count = ', count)

_______________________________________________________________________________________________________________________________________________________________________________


//Алгоритм бинарного поиска, может работать с упорядоченным списком!



const array = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
let count = 0

function binarySearch(array, item) {
    let start = 0
    let end = array.length
    let middle;
    let found = false
    let position = -1
    while (found === false && start <= end) {
        count+=1
        middle = Math.floor((start + end) / 2);
        if (array[middle] === item) {
            found = true
            position = middle
            return position;
        }
        if (item < array[middle]) {
            end = middle - 1
        } else {
            start = middle + 1
        }
    }
    return position;
}

function recursiveBinarySearch(array, item, start, end) {
    let middle = Math.floor((start + end) / 2);
    count += 1
    if (item === array[middle]) {
        return middle
    }
    if (item < array[middle]) {
        return recursiveBinarySearch(array, item, 0, middle - 1 )
    } else {
        return recursiveBinarySearch(array, item, middle + 1, end )
    }
}

console.log(recursiveBinarySearch(array, 0, 0, array.length))
console.log(count)












_______________________________________________________________________________________________________________________________________________________________________________


//Сортировка выбором selection sort

const arr = [0,3,2,5,6,8,1,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,6,2,35,6,3,32] // [0,1,1,2,3.......]
let count = 0

function selectionSort(array) {
    for (let i = 0; i < array.length; i++) {
        let indexMin = i
        for (let j = i+1; j < array.length; j++) {
            if (array[j] < array[indexMin]) {
                indexMin = j
            }
            count += 1
        }
        let tmp = array[i]
        array[i] = array[indexMin]
        array[indexMin] = tmp
    }
    return array
}

console.log(selectionSort(arr))
console.log(arr.length) // O(n*n)
console.log('count = ', count)




_______________________________________________________________________________________________________________________________________________________________________________

// Сортировка пузырьком BubbleSort



const arr = [0,3,2,5,6,8,23,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,6,2,35,6,3,32,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,]
let count = 0

function bubbleSort(array) {
    for (let i = 0; i < array.length; i++) {
        for (let j = 0; j < array.length; j++) {
            if (array[j + 1] < array[j]) {
                let tmp = array[j]
                array[j] = array[j+1]
                array[j+1] = tmp
            }
            count+=1
        }
    }
    return array
}

console.log('length', arr.length)
console.log(bubbleSort(arr)) // O(n*n)
console.log('count = ', count)






//

_______________________________________________________________________________________________________________________________________________________________________________

//Рекурсия 

const factorial = (n) => {
    if (n === 1) {
        return 1
    }
    return n * factorial(n - 1)
}

// Числа фибоначчи -  1,1,2,3,5,8,13,21

const fibonachi = (n) => {
    if (n === 1 || n === 2) {
        return 1
    }
    return fibonachi(n-1) + fibonachi(n-2)
}

console.log(fibonachi(8))













_______________________________________________________________________________________________________________________________________________________________________________




//Сортировка Хоара    quich_sort




const arr = [0,3,2,5,6,8,23,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,6,2,35,6,3,32,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,9,4,2,1,2,9,6,4,1,7,-1, -5, 23,]
let count = 0

function quickSort(array) {
    if (array.length <= 1) {
        return array
    }
    let pivotIndex = Math.floor(array.length / 2);
    let pivot = array[pivotIndex]
    let less = []
    let greater = []
    for (let i = 0; i < array.length; i++) {
        count += 1
        if(i === pivotIndex)
            continue
        if (array[i] < pivot) {
            less.push(array[i])
        } else {
            greater.push(array[i])
        }
    }
    return [...quickSort(less), pivot, ...quickSort(greater)]
}

console.log(quickSort(arr))
console.log('count', count)





//















_____________________________________________________________________________________________________________________________________________________________________________

//Кеширование вычеслений


function cashFunction(fn) {
    const cash = {}
    return function (n) {
        if (cash[n]) {
            console.log('Взято из кеша', cash[n])
            return cash[n]
        }
        let result = fn(n)
        console.log('Посчитала функция = ', result)
        cash[n] = result
        return result;
    };
}

function factorial(n) {
    let result = 1
    while (n != 1) {
        result *= n
        n -= 1
    }
    return result
}

const cashFactorial = cashFunction(factorial)

cashFactorial(5)
cashFactorial(4)
cashFactorial(3)
cashFactorial(4)
cashFactorial(5)
cashFactorial(1)







_________________________________________________________________________________________________________________________________________________________________________






/*Основные структуры данных.

Массивы
Стеки
Очереди
Связанные списки
Графы
Деревья
Префиксные деревья
Хэш таблицы*/






_______________________________________________________________________________________________________________________________________________________________________________


//Массивы 



/*Массивы

Массив — это самая простая и широко используемая структура данных. Другие структуры данных, такие как стеки и очереди, являются производными от массивов.

Изображение простого массива размера 4, содержащего элементы (1, 2, 3 и 4).



Каждому элементу данных присваивается положительное числовое значение (индекс), который соответствует позиции элемента в массиве. Большинство языков определяют начальный индекс массива как 0.

Бывают

Одномерные, как показано выше.
Многомерные, массивы внутри массивов.

Основные операции

Insert-вставляет элемент по заданному индексу
Get-возвращает элемент по заданному индексу
Delete-удаление элемента по заданному индексу
Size-получить общее количество элементов в массиве

Вопросы

Найти второй минимальный элемент массива
Первые неповторяющиеся целые числа в массиве
Объединить два отсортированных массива
Изменение порядка положительных и отрицательных значений в массиве*/









_______________________________________________________________________________________________________________________________________________________________________________

//Стеки


/*Стек — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»).

Это не массивы. Это очередь. Придумал Алан Тюринг.

Примером стека может быть куча книг, расположенных в вертикальном порядке. Для того, чтобы получить книгу, которая где-то посередине, вам нужно будет удалить все книги, размещенные на ней. Так работает метод LIFO (Last In First Out). Функция «Отменить» в приложениях работает по LIFO.

Изображение стека, в три элемента

    3  <-- TOP
    2
    1 где 3 находится наверху и будет удален первым.



Основные операции

Push-вставляет элемент сверху
Pop-возвращает верхний элемент после удаления из стека
isEmpty-возвращает true, если стек пуст
Top-возвращает верхний элемент без удаления из стека

Вопросы

Реализовать очередь с помощью стека
Сортировка значений в стеке
Реализация двух стеков в массиве
Реверс строки с помощью стека*/




_________________________________________________________________________________________________________________________________________________________________________________


//Очереди

/*Подобно стекам, очередь — хранит элемент последовательным образом. Существенное отличие от стека – использование FIFO (First in First Out) вместо LIFO.

Пример очереди – очередь людей. Последний занял последним и будешь, а первый первым ее и покинет.

Изображение очереди, в четыре элемента (1, 2, 3 и 4), где 1 находится наверху и будет удален первым

    
Удалить последний элемент< _
                            |
                            1  <-- FRONT
                            2
                            3
                            4  <-- BACk
                            ^
                            |
                            -- Добавить новый элемент






Основные операции

Enqueue—) — вставляет элемент в конец очереди
Dequeue () — удаляет элемент из начала очереди
isEmpty () — возвращает значение true, если очередь пуста
Top () — возвращает первый элемент очереди

Вопросы

Реализовать cтек с помощью очереди
Реверс первых N элементов очереди
Генерация двоичных чисел от 1 до N с помощью очереди*/






_______________________________________________________________________________________________________________________________________________________________________________

//связанные списки



/*Связанный список

Связанный список – массив где каждый элемент является отдельным объектом и состоит из двух элементов – данных и ссылки на следующий узел.

Принципиальным преимуществом перед массивом является структурная гибкость: порядок элементов связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера, а порядок обхода списка всегда явно задаётся его внутренними связями.

Бывают

Однонаправленный, каждый узел хранит адрес или ссылку на следующий узел в списке и последний узел имеет следующий адрес или ссылку как NULL.

1->2->3->4->NULL

Двунаправленный, две ссылки, связанные с каждым узлом, одним из опорных пунктов на следующий узел и один к предыдущему узлу.

NULL<-1<->2<->3->NULL

Круговой, все узлы соединяются, образуя круг. В конце нет NULL. Циклический связанный список может быть одно-или двукратным циклическим связанным списком.

1->2->3->1

Самое частое, линейный однонаправленный список. Пример – файловая система.



Основные операции

InsertAtEnd — Вставка заданного элемента в конец списка
InsertAtHead — Вставка элемента в начало списка
Delete — удаляет заданный элемент из списка
DeleteAtHead — удаляет первый элемент списка
Search — возвращает заданный элемент из списка
isEmpty — возвращает True, если связанный список пуст

Вопросы

Реверс связанного списка
Определение цикла в связанном списке
Возврат N элемента из конца в связанном списке
Удаление дубликатов из связанного списка */









//алгоритм для связного списка

class LinkedList {
    constructor() {
        this.size = 0
        this.root = null
    }

    add(value) {
        if (this.size === 0) {
            this.root = new Node(value);
            this.size += 1;
            return true;
        }
        let node = this.root
        while (node.next) {
            node = node.next
        }
        let newNode = new Node(value)
        node.next = newNode
        this.size += 1
    }

    getSize() {
        return this.size
    }

    print() {
        let result = []
        let node = this.root
        while (node) {
            result.push(node.value)
            node = node.next
        }
        console.log(result);;
    }
}

class Node {
    constructor(value) {
        this.value = value
        this.next = null
    }
}

const list = new LinkedList()
list.add(5)
list.add(3)
list.add(2)
list.add(5)
list.add(7)

list.print()









____________________________________________________________________________________________________________________________________________________________________________

//графы




/*Граф-это набор узлов (вершин), которые соединены друг с другом в виде сети ребрами (дугами).







         
                               

                     (b)<----(C)
                              ^
                              |   <-- Edge(Ребра)
   (Вершины) Vertex --> (a)----




Бывают

Ориентированный, ребра являются направленными, т.е. существует только одно доступное направление между двумя связными вершинами.
Неориентированные, к каждому из ребер можно осуществлять переход в обоих направлениях.
Смешанные

Встречаются в таких формах как

Матрица смежности
Список смежности

Общие алгоритмы обхода графа

Поиск в ширину – обход по уровням
Поиск в глубину – обход по вершинам

Вопросы

Реализовать поиск по ширине и глубине
Проверить является ли граф деревом или нет
Посчитать количество ребер в графе
Найти кратчайший путь между двумя вершинами*/




// Поиск в ширину в графе

const graph = {}
graph.a = ['b', 'c']
graph.b = ['f']
graph.c = ['d', 'e']
graph.d = ['f']
graph.e = ['f']
graph.f = ['g']

function breadthSearch(graph, start, end) {
    let queue = []
    queue.push(start)
    while (queue.length > 0) {
        const current = queue.shift()
        if (!graph[current]) {
            graph[current] = []
        }
        if (graph[current].includes(end)) {
            return true
        } else {
            queue = [...queue, ...graph[current]]
        }
    }
    return false
}

console.log(breadthSearch(graph, 'a', 'e'))










// Поиск кратчайшего пути в графе

const graph = {}
graph.a = {b: 2, c: 1}
graph.b = {f: 7}
graph.c = {d: 5, e: 2}
graph.d = {f: 2}
graph.e = {f: 1}
graph.f = {g: 1}
graph.g = {}

function shortPath(graph, start, end) {
    const costs = {}
    const processed = []
    let neighbors = {}
    Object.keys(graph).forEach(node => {
        if (node !== start) {
            let value = graph[start][node]
            costs[node] = value || 100000000
        }
    })
    let node = findNodeLowestCost(costs, processed)
    while (node) {
        const cost = costs[node]
        neighbors = graph[node]
        Object.keys(neighbors).forEach(neighbor => {
            let newCost = cost + neighbors[neighbor]
            if (newCost < costs[neighbor]) {
                costs[neighbor] = newCost
            }
        })
        processed.push(node)
        node = findNodeLowestCost(costs, processed)
    }
    return costs
}


function findNodeLowestCost(costs, processed) {
    let lowestCost = 100000000
    let lowestNode;
    Object.keys(costs).forEach(node => {
        let cost = costs[node]
        if (cost < lowestCost && !processed.includes(node)) {
            lowestCost = cost
            lowestNode = node
        }
    })
    return lowestNode
}

console.log(shortPath(graph, 'a', 'g'));










// Матрица смежности

const matrix = [
    [0,1,1,0,0,0,0],
    [0,0,0,0,1,0,0],
    [0,0,0,1,0,1,0],
    [0,0,0,0,1,0,0],
    [0,0,0,0,0,0,1],
    [0,0,0,0,1,0,0],
    [0,0,0,0,0,0,0],
]









_______________________________________________________________________________________________________________________________________________________________________



//Деревья

/*Деревья

Дерево-это иерархическая структура данных, состоящая из узлов (вершин) и ребер (дуг). Деревья по сути связанные графы без циклов.

Древовидные структуры везде и всюду. Дерево скилов в играх знают все.

Простое дерево:



                    ___1___
                   |   |   |    (Допустим как DOM дерево)       1) Root
                   2   3   4                                    1,3)Perent
                      _|_                                      2,3,4 6,7) Child
                     |   |                                     2,4,6,7)Leaf
                      6 7                                      2,3,4, 6,7)Sibling




  





Типы деревьев
N дерево
Сбалансированное дерево
Бинарное дерево
Дерево Бинарного Поиска
AVL дерево
2-3-4 деревья

Бинарное дерево самое распространенное.

«Бинарное дерево — это иерархическая структура данных, в которой каждый узел имеет значение (оно же является в данном случае и ключом) и ссылки на левого и правого потомка. » — Procs

Три способа обхода дерева

В прямом порядке (сверху вниз) — префиксная форма.
В симметричном порядке (слева направо) — инфиксная форма.
В обратном порядке (снизу вверх) — постфиксная форма.

Вопросы

Найти высоту бинарного дерева
Найти N наименьший элемент в двоичном дереве поиска
Найти узлы на расстоянии N от корня
Найти предков N узла в двоичном дереве*/









const tree = [
    {
        v: 5,
        c: [
            {
                v:10,
                c: [
                    {
                        v:11,
                    }
                ]
            },
            {
                v:7,
                c: [
                    {
                        v:5,
                        c: [
                            {
                                v:1
                            }
                        ]
                    }
                ]
            }
        ]
    },
    {
        v: 5,
        c: [
            {
                v:10
            },
            {
                v:15
            }
        ]
    }
]
// Рекурсивный обход дерева
const recursive = (tree) => {
    let sum = 0;
    tree.forEach(node => {
        sum += node.v
        if(!node.c) {
            return node.v
        }
        sum += recursive(node.c)
    })
    return sum
}



// Итеративный обход дерева с помощью стека
const iteration = (tree) => {
    if (!tree.length) {
        return 0
    }
    let sum = 0
    let stack = []
    tree.forEach(node => stack.push(node));
    while (stack.length) {
        const node = stack.pop()
        sum += node.v
        if (node.c) {
            node.c.forEach(child => stack.push(child))
        }
    }
    return sum
}

console.log(iteration(tree))
// console.log(recursive(tree))


















//Бинарное Дерево поиска

class BinaryTree {
    constructor() {
        this.root = null
    }

    add(value) {
        if (!this.root) {
            this.root = new TreeNode(value)
        } else {
            let node = this.root
            let newNode = new TreeNode(value)
            while (node) {
                if (value > node.value) {
                    if (!node.right) {
                        break
                    }
                    node = node.right
                } else {
                    if (!node.left) {
                        break
                    }
                    node = node.left
                }
            }
            if (value > node.value) {
                node.right = newNode
            } else {
                node.left = newNode
            }
        }
    }

    print(root = this.root) {
        if (!root) {
            return true;
        }
        console.log(root.value);
        this.print(root.left)
        this.print(root.right)
    }
}

class TreeNode {
    constructor(value) {
        this.value = value
        this.left = null
        this.right = null
    }
}

const tree = new BinaryTree()
tree.add(5)
tree.add(2)
tree.add(6)
tree.add(2)
tree.add(1)
tree.print()











_______________________________________________________________________________________________________________________________________________________________________________



//Префиксное Дерево Trie



/*Разновидность дерева для строк, быстрый поиск. Словари. Т9.

Вот как такое дерево хранит слова «top», «thus» и «their».


                        root
                         |
                         t
                      ___|___
                      o      h
                           __|_______
                           t    u   e
                                |   |
                                s   i
                                    |
                                    r 
                      




Слова хранятся сверху вниз, зеленые цветные узлы «p», «s» и «r» указывают на конец «top», «thus « и «their» соответственно.

Вопросы

Подсчитать общее количество слов
Вывести все слова
Сортировка элементов массива с префиксного дерева
Создание словаря T9 */








_______________________________________________________________________________________________________________________________________________________________________________







//Хеш Таблицы

/*Хэширование — это процесс, используемый для уникальной идентификации объектов и хранения каждого объекта в заранее рассчитанном уникальном индексе (ключе).

Объект хранится в виде пары «ключ-значение», а коллекция таких элементов называется «словарем». Каждый объект можно найти с помощью этого ключа.

По сути это массив, в котором ключ представлен в виде хеш-функции.

Эффективность хеширования зависит от

Функции хеширования
Размера хэш-таблицы
Метода борьбы с коллизиями

Пример сопоставления хеша в массиве. Индекс этого массива вычисляется через хэш-функцию.


    1    <key>:<data>
        
    3    <key>:<data>
    4    <key>:<data>
    80...<key>:<data>


Вопросы

Найти симметричные пары в массиве
Найти, если массив является подмножеством другого массива
Описать открытое хеширование*/








_______________________________________________________________________________________________________________________________________________________________________________


//set -map
const map = new Map()
const objKey = {id:5}
map.set(objKey, "ulbi tv")

console.log(map.get(objKey));

const set = new Set()

set.add(5)
set.add(5)
set.add(5)
set.add(5)
set.add(5)
set.add(4)
set.add(3)
console.log(set)


